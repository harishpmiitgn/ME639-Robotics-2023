# -*- coding: utf-8 -*-
"""Assignment3_4__question4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IbLSkt-BumPn8p97mCcqFPEtfJkYultc
"""

For Stanford And Scara , Configuration is RRP but the difference is in DH parameters.

"""For Standford Configuration:"""

import numpy as np

#Calculate transformation matrix
def DH_Matrix(theta, d, a, alpha):
    C_theta = np.cos(theta)
    S_theta = np.sin(theta)
    S_alpha = np.cos(alpha)
    C_alpha = np.sin(alpha)


    Transformation_Matrix = np.array([
        [C_theta, -S_theta * C_alpha, S_theta * S_alpha, a * C_theta],
        [S_theta, C_theta * C_alpha, -C_theta * S_alpha, a * S_theta],
        [0, S_alpha, C_alpha, d],
        [0, 0, 0, 1]
    ])

    return Transformation_Matrix

def end_effector_position(DHparameters):
    No_ofjoints = len(DHparameters)
    T = np.identity(4)
    for i in range(No_ofjoints):
        theta, d, a, alpha = DHparameters[i]
        T_i = DH_Matrix(theta, d, a, alpha)
        T = np.dot(T, T_i)  #Multipication of all Transformation matrices!!
    return T[:3, 3] #End effector coordinates(x,y,z)

def Jacobian(DHparameters,Nature_of_joint):

    No_ofjoints = len(DHparameters)
    T = np.identity(4)
    J = np.zeros((6, No_ofjoints))
    end_effector_pos = end_effector_position(DHparameters)

    for i in range(No_ofjoints):
        theta, d, a, alpha = DHparameters[i]
        T_i = DH_Matrix(theta, d, a, alpha)
        T = np.dot(T, T_i)


        if Nature_of_joint[i] == 'R':  # Revolute
            z = T[:3, 2]
            p = end_effector_pos - T[:3, 3]
            J[:3, i] = np.cross(z, p)
            J[3:, i] = z
        else:                           #Prismatic
            z = T[:3, 2]
            J[:3, i] = z

    return J

def joint_velocities(J, X_dot):

    q = np.dot(np.linalg.pinv(J), X_dot)
    return q


# Example of Stanford Robot  ( From Textbook )
Nature_of_joint = ["R", "R", "P", "R",  "R",  "R"]
DHparameters = [
    [0, 0, 0, -np.pi/2],
    [-np.pi/6, 1, 0, np.pi/2],
    [0, 1, 0, 0],
    [0,0,0,-np.pi/2],
    [0, 0, 0, np.pi/2 ],
    [0, 1, 0, 0 ]
    ]



end_effector_velocity = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6])

Jacobian_Matrix = Jacobian(DHparameters, Nature_of_joint)
end_effector_pos = end_effector_position(DHparameters)
joint_velocity = joint_velocities(Jacobian_Matrix, end_effector_velocity)

print("Manipulator Jacobian:")
print(Jacobian_Matrix)
print("End-effector Position:")
print(end_effector_pos)
print("End-effector Velocity:")
print(joint_velocity)

"""For Scara :"""

import numpy as np

#Calculate transformation matrix
def DH_Matrix(theta, d, a, alpha):
    C_theta = np.cos(theta)
    S_theta = np.sin(theta)
    S_alpha = np.cos(alpha)
    C_alpha = np.sin(alpha)


    Transformation_Matrix = np.array([
        [C_theta, -S_theta * C_alpha, S_theta * S_alpha, a * C_theta],
        [S_theta, C_theta * C_alpha, -C_theta * S_alpha, a * S_theta],
        [0, S_alpha, C_alpha, d],
        [0, 0, 0, 1]
    ])

    return Transformation_Matrix

def end_effector_position(DHparameters):
    No_ofjoints = len(DHparameters)
    T = np.identity(4)
    for i in range(No_ofjoints):
        theta, d, a, alpha = DHparameters[i]
        T_i = DH_Matrix(theta, d, a, alpha)
        T = np.dot(T, T_i)  #Multipication of all Transformation matrices!!
    return T[:3, 3] #End effector coordinates(x,y,z)

def Jacobian(DHparameters, Nature_of_joint):

    No_ofjoints = len(DHparameters)
    T = np.identity(4)
    J = np.zeros((6, No_ofjoints))
    end_effector_pos = end_effector_position(DHparameters)

    for i in range(No_ofjoints):
        theta, d, a, alpha = DHparameters[i]
        T_i = DH_Matrix(theta, d, a, alpha)
        T = np.dot(T, T_i)



        if Nature_of_joint[i] == 'R':  # Revolute
            z = T[:3, 2]
            p = end_effector_pos - T[:3, 3]
            J[:3, i] = np.cross(z, p)
            J[3:, i] = z
        else:                           #Prismatic
            z = T[:3, 2]
            J[:3, i] = z

    return J

def joint_velocities(J, X_dot):

    q = np.dot(np.linalg.pinv(J), X_dot)
    return q


# Example of Scara
Nature_of_joint = ["R", "R", "P", "R"]
DHparameters = [
    [0, 0, 1, 0],
    [-np.pi/6, 0, 0, np.pi],
    [0, 1, 0, 0],
    [0,1,0,0]
    ]



end_effector_velocity = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6])

Jacobian_Matrix = Jacobian(DHparameters, Nature_of_joint)
end_effector_pos = end_effector_position(DHparameters)
joint_velocity = joint_velocities(Jacobian_Matrix, end_effector_velocity)

print("Manipulator Jacobian:")
print(Jacobian_Matrix)
print("End-effector Position:")
print(end_effector_pos)
print("End-effector Velocity:")
print(joint_velocity)